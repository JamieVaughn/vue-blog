---
title: Javascript's Immutability Toolkit
lang: en-US
date: 2020-7-26 12:00:00
excerpt: A list of methods native to Javascript that conserve immutability of data.
type: post
blog: true
tags:
    - JavaScript
meta:
  - name: description
    content: A list of methods native to Javascript that conserve immutability of data.
  - name: keywords
    content: Immutable, javascript, methods
---

# Blog post


Check MDN's [Array methods in the side bar on the left](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#) for an exhaustive list.
## Non Mutating Methods
.slice
.flat()
.concat
[...args]
Object.assign({}, obj)
Object.keys, .values. entries() // to manipulate Object as Array then convert back
Object.freeze()
arr.map()
.flatMap()
arr.filter()
arr.reduce/reduceRight()
arr.some()
arr.every()
arr.find()
arr.findIndex()
.join(), toString()


function (arg) {
  return data
}

const & Object.freeze()

Upcoming Records and Tuples

## Mutating Methods 
.push()
.pop()
.shift()
.unshift()
.splice()
.sort() // use .slice(0).sort() or [...arr].sort()
.reverse()
.copyWithin()
.forEach()
Object.create() // Mutating in the sense that it inherits prototype properties which cna be overwritten

## Why Favor Immutability

State management
Pure Functions
Race Conditions

## Downsides

Uses more memory... but memory isn't in short supply with today's hardware.

## Cautionary Tale

Using Array(10).fill({id: 0}) creates an array where every element is a reference to the same object. So if you plan to try to use those objects as independent state, you will have a very weird bug that is hard to track if you don't know about this. Thankfully using .map() can help: Array(10).fill(0).map((item, index) =>  ({id: index})) will create unique objects in each position of the array.
Array.from({length: 32}, () => {id: 1})