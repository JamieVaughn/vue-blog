---
title: The Null Object Pattern in the Functional Style
lang: en-US
date: 2020-02-20 8:50:00
excerpt: Let's see how to create a Null Object pattern in Javascript
type: post
blog: true
tags:
    - Javascript
meta:
  - name: description
    content: how to create a Null Object pattern in Javascript and what it is
  - name: keywords
    content: create Null Object pattern Javascript
---

The Null Object Pattern is a common way in OOP to handle `null` references in a graceful way. If a reference to an object is `null` and a method is invoked on that reference, then this will cause an error. Instead, a Null Object can be implemented with the same interface, but where the methods are no-op methods. Other objects can inherit from this Null Object in such a way, that if a `null` reference is passed then they will use the no-op methods from the Null Object rather than throwing an error. 

## Typical OOP implementation in JS

```js
class Discount {
  calculateDiscount() {
    return 0.15;
  }
}
class NoDiscount {
  calculateDiscount() {
    return null;
  }
}
function getDiscount(orderType) {
  return orderType === 'matinée' ? new Discount() : new NoDiscount();
}

[new Discount('matinée'), null].map(o => getDiscount(o).sound())
```
Using the null object pattern, a special version of the Class is created that has the same method and signature, but it only handles `null` values and mitigates the need for more tedious control flow logic that checks for `null` values in the original class interface. 

## Typical Functional implementation in JS

This is the older way to implement the Null Object Pattern in an OOP style. A functional style of handling it would look like this:

```js
function Discounts(type) {
   let types = {
    regular: {
      calc() {return 0.15}
    },
    nullDiscount: {
      calc() {return null}
    }
  }
  return types[type] || types.nullDiscount
}
Discounts('regular').calc()
Discounts(null).calc()
```

## ECMAScript 20202: Is this pattern necessary anymore?

In the latest version of ECMAScript there are a couple of operators that more or less obviate the need to implement a custom Null Object handler. They are called Optional Chaining (`.?`) and Nullish Coalescing (`??`)

Optional Chaining can be used when trying to access methods or properties on any object such that accessing an undefined property will not cause an error and instead it can be handled with minimal control flow. It would look like this:

```js
class Discount {
  calc() {
    return 0.15;
  }
  days = 'MTWTF'
}
let special = new Discount
special.calc?.() // 0.15
special.order?.() // undefined
special.order?.() || 'No specials' // 'No specials' 
special.day // undefined anyways so optional chaining is not needed for properties
```

This works the same for JS objects:
```js
let obj = {
  days: 'MWT',
  order: () => 'burger & fries'
  points: () => 0
}

obj.day // undefined already
obj.special() // Uncaught TypeError
obj.special?.() // undefined
```

And we can combine this with Nullish Coallescing to get a fully operational Null Object Handling in one line anywhere in our code when referencing potentially non-existent methods :

```js
// using obj from previous code block
obj.special?.() ?? 'No Special' // 'No Special'
obj.points?.() || 'Could not fetch points' // 'Could not fetch points
obj.points?.() ?? 'Could not fetch points' // 0
```

So we can see the Nullish Coalescer allows us to handle null and undefined methods alongside methods that may return falsy values like `0` or `''` or `false`. 

So is optional chaining combined with nullish coalescing enough to recreate the Null Object pattern in JS? I think so, but perhaps other may still build something more robust like Maybe Monads or Null Object Handling Classes. But I'll stick with these two new tools form ECMAScript myself.